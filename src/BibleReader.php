<?php
/**
 * BibleReader unit
 *
 * @package OrderOfMass
 * @author  Tommander <tommander@tommander.cz>
 * @license MIT license https://opensource.org/licenses/MIT
 */

declare(strict_types=1);

namespace TMD\OrderOfMass;

use TMD\OrderOfMass\Models\{BibleindexModel,BiblejsonModel,BiblemapModel,BooklistModel,LanglabelsModel};
use TMD\OrderOfMass\Exceptions\{OomException,ModelException};

if (defined('OOM_BASE') !== true) {
    die('This file cannot be viewed independently.');
}

/**
 * Reader for Zefania Bible translations.
 *
 * This class can get verses based on verse references, translate book numbers to book names and render whole Bible translation.
 *
 * It is working with the submodule `zefania-bibles`, where it reads the JSON files generated from original XMLs.
 */
class BibleReader
{

    /**
     * Whether to take verse parts into account.
     *
     * This is an EXPERIMENTAL functionality and doesn't always work correctly, that is why this constant is `false` by default.
     *
     * This is how the constant works e.g. for reference "Ps 9:10a":
     *
     * - Constant is `false`: verse reference will process this as "Ps 9:10"
     * - Constant is `true`: only first part of the 10th verse will be returned
     *
     * @var boolean
     */
    private $allowSubref = false;

    /**
     * GetParams service instance
     *
     * @var GetParams
     */
    private $getParams;

    /**
     * Logger service instance
     *
     * @var Logger
     */
    private $logger;

    /**
     * Language service instance
     *
     * @var Language
     */
    private $language;

    /**
     * Hello
     *
     * @var BibleindexModel
     */
    private $bibleIndexModel;

    /**
     * Hello
     *
     * @var BiblejsonModel
     */
    private $bibleJsonModel;

    /**
     * Hello
     *
     * @var BiblemapModel
     */
    private $bibleMapModel;

    /**
     * Hello
     *
     * @var BooklistModel
     */
    private $bookListModel;

    /**
     * Hello
     *
     * @var LanglabelsModel
     */
    private $langLabelsModel;


    /**
     * Generate a unique verse reference number
     *
     * The range of an (un)signed 32b integer should be sufficient for the returned number.
     *
     * @param int $book Book number
     * @param int $chap Chapter number (3 digits)
     * @param int $ver  Verse number (3 digits)
     * @param int $part Part number (1 digit)
     *
     * @return int
     */
    private static function refVer(int $book, int $chap, int $ver, int $part=0): int
    {
        return (int) sprintf('%d%03d%03d%01d', $book, $chap, $ver, $part);

    }//end refVer()


    /**
     * Decodes a unique verse reference number generated by {@see BibleReader::refVer()}.
     *
     * @param int $refVer Unique verse reference number.
     *
     * @return array
     */
    private static function decodeRefVer(int $refVer): array
    {
        $ret = [
            'book' => 0,
            'chap' => 0,
            'vers' => 0,
            'part' => 0,
        ];

        $strRefVer = strval($refVer);
        if (preg_match('/^(\d+)(\d{3})(\d{3})(\d{1})$/', $strRefVer, $mat) === 1) {
            $ret['book'] = intval($mat[1]);
            $ret['chap'] = intval($mat[2]);
            $ret['vers'] = intval($mat[3]);
            $ret['part'] = intval($mat[4]);
        }

        return $ret;

    }//end decodeRefVer()


    /**
     * Constructor
     *
     * Saves service instances and loads Bible translations list
     *
     * @param Logger          $logger          Logger service
     * @param GetParams       $getParams       GetParams service
     * @param Language        $language        Language service
     * @param BibleindexModel $bibleIndexModel Bibleindex model
     * @param BiblejsonModel  $bibleJsonModel  Biblejson model
     * @param BiblemapModel   $bibleMapModel   Biblemap model
     * @param BooklistModel   $bookListModel   Booklist model
     * @param LanglabelsModel $langLabelsModel Langlabels model
     */
    public function __construct(Logger $logger, GetParams $getParams, Language $language, BibleindexModel $bibleIndexModel, BiblejsonModel $bibleJsonModel, BiblemapModel $bibleMapModel, BooklistModel $bookListModel, LanglabelsModel $langLabelsModel)
    {
        // Services.
        $this->logger          = $logger;
        $this->getParams       = $getParams;
        $this->language        = $language;
        $this->bibleIndexModel = $bibleIndexModel;
        $this->bibleJsonModel  = $bibleJsonModel;
        $this->bibleMapModel   = $bibleMapModel;
        $this->bookListModel   = $bookListModel;
        $this->langLabelsModel = $langLabelsModel;

    }//end __construct()


    /**
     * Sort of "pre-function" for {@see BiblejsonModel::getVerseRange()} which parses the given verse reference and book abbreviation.
     *
     * @param string $ref Verse reference
     *
     * @return string
     */
    public function getVerse(string $ref): string
    {
        $ret       = '';
        $parsedRef = $this->parseRef($ref);

        foreach ($parsedRef as $oneRef) {
            if (is_array($oneRef) !== true || count($oneRef) !== 2) {
                throw new OomException('Unexpected parsed verse reference structure.');
            }

            if ($ret !== '') {
                $ret .= ' ';
            }

            $ret .= $this->bibleJsonModel->getVerseRange($oneRef[0], $oneRef[1]);
        }

        return $ret;

    }//end getVerse()


    /**
     * Parse single string reference to elementary parts.
     *
     * This is important for the XML parser to be able to follow any possible verse reference.
     *
     * It is important to note that the input reference may only contain one book ref.
     *
     * Parsing `Ps 1:2-3, 4b-2:4+5` would give this result:
     *
     * ```
     * array(
     *     ['Ps', 1000200, 1000300],
     *     ['Ps', 1000202, 2000400],
     *     ['Ps', 2000500, 2000500]
     * )
     * ```
     *
     * @param string $ref One reference
     *
     * @return array
     */
    public function parseRef(string $ref): array
    {
        // Check that book reference and the rest of the reference was found.
        if (preg_match('/^([\p{L}0-9]+)\s+(.*)$/u', $ref, $mat) !== 1 || count($mat) < 3) {
            throw new OomException('Unparsable verse reference "'.$ref.'"');
        }

        // Save basic reference parts for clarity.
        $book    = $mat[1];
        $chap    = 0;
        $bookNum = $this->bookListModel->abbreviationToNumber($book);

        // Split reference into single verses or verse ranges.
        $rngArr = [];
        $rngTok = strtok($mat[2], ',+');
        while ($rngTok !== false) {
            $rngArr[] = $rngTok;
            $rngTok   = strtok(',+');
        }

        // Unification of all single verse/verse range refs, so that
        // they all have book and chapter.
        $rng = [];
        foreach ($rngArr as $rngOne) {
            if (preg_match('/(([0-9]+):)?([0-9A-z]+)(-)?(([0-9]+):)?([0-9A-z]+)?/', $rngOne, $mat2) !== 1) {
                throw new OomException('Unparsable verse reference "'.$rngOne.'"');
            }

            $verseLow  = '';
            $verseHigh = '';

            if (count($mat2) === 4) {
                if ($mat2[2] !== '') {
                    $chap = intval($mat2[2]);
                }

                if (preg_match('/(\d+)([A-z]{1})/', $mat2[3], $mat3) === 1) {
                    if ($this->allowSubref === true) {
                        $verseLow = self::refVer($bookNum, $chap, intval($mat3[1]), Helper::letterToInt($mat3[2]));
                    } else {
                        $verseLow = self::refVer($bookNum, $chap, intval($mat3[1]));
                    }
                } else {
                    $verseLow = self::refVer($bookNum, $chap, intval($mat2[3]));
                }

                $verseHigh = $verseLow;
            } else if (count($mat2) === 8) {
                if ($mat2[2] !== '') {
                    $chap = intval($mat2[2]);
                }

                if (preg_match('/(\d+)([A-z]{1})/', $mat2[3], $mat4) === 1) {
                    if ($this->allowSubref === true) {
                        $verseLow = self::refVer($bookNum, $chap, intval($mat4[1]), Helper::letterToInt($mat4[2]));
                    } else {
                        $verseLow = self::refVer($bookNum, $chap, intval($mat4[1]));
                    }
                } else {
                    $verseLow = self::refVer($bookNum, $chap, intval($mat2[3]));
                }

                if ($mat2[6] !== '') {
                    $chap = intval($mat2[6]);
                }

                if (preg_match('/(\d+)([A-z]{1})/', $mat2[7], $mat5) === 1) {
                    if ($this->allowSubref === true) {
                        $verseHigh = self::refVer($bookNum, $chap, intval($mat5[1]), Helper::letterToInt($mat5[2]));
                    } else {
                        $verseHigh = self::refVer($bookNum, $chap, intval($mat5[1]));
                    }
                } else {
                    $verseHigh = self::refVer($bookNum, $chap, intval($mat2[7]));
                }
            } else {
                throw new OomException('Strange verse reference "'.$rngOne.'"');
            }//end if

            $rng[] = [
                $verseLow,
                $verseHigh,
            ];
        }//end foreach

        return $rng;

    }//end parseRef()


    /**
     * Allows for parsing either a single string reference or an array of string references.
     *
     * Basically it is just a <q>gate</q> to {@see BibleReader::parseRef()}.
     *
     * @param string|string[] $refs Reference(s)
     *
     * @return array
     */
    public function parseRefs(string|array $refs): array
    {
        if (is_string($refs) === true) {
            return $this->parseRef($refs);
        }

        $arr = [];
        foreach ($refs as $oneref) {
            $arr = array_merge($arr, $this->parseRef($oneref));
        }

        return $arr;

    }//end parseRefs()


    /**
     * Renders the whole current Bible translation.
     *
     * @return string
     */
    public function renderBible(): string
    {
        // List of books ['bookNumber' => 'bookName'].
        $toc = [];

        // Rendered book text (all chapters and verses).
        $text = '';

        // List of chapters in currently selected book ['chap<number>' => '<number>].
        $tocChaps = [];

        // Number of the currently selected book.
        $selectBook = intval($this->getParams->getParam(GetParams::PARAM_BOOK));

        // Create list of books in currently selected Bible.
        // If a book is selected, render its chapters and verses.
        $verses = $this->bibleJsonModel->listVerses();
        foreach ($verses as $verseID) {
            if (is_int($verseID) !== true) {
                throw new OomException('Verse ID is not integer');
            }

            // Explode verse reference.
            $verseData  = self::decodeRefVer($verseID);
            $bookNumStr = strval($verseData['book']);

            // Add book to ToC if it is not there yet.
            if (array_key_exists($bookNumStr, $toc) !== true) {
                $bookName = '';

                // Try to load the localized book name, if not, we use the common English name.
                $bookNameTmp = $this->bibleMapModel->numberToName($verseData['book']);
                if ($bookNameTmp !== '') {
                    $bookName = $bookNameTmp;
                } else {
                    $bookName = $this->bookListModel->numberToName($verseData['book']);
                }

                $toc[$verseData['book']] = $bookName;
            }

            // If the current verse's book is not equal to the selected book, skip.
            if ($selectBook !== $verseData['book']) {
                continue;
            }

            // Add book heading if we are at the first chapter and first verse.
            if ($verseData['chap'] === 1 && $verseData['vers'] === 1) {
                $text .= "<h2>".$toc[$bookNumStr]."</h2>\r\n";
            }

            // Add chapter heading if we are at the first verse.
            if ($verseData['vers'] === 1) {
                $text .= "<h3 id=\"chap".$verseData['chap']."\">".$this->langLabelsModel->getLabel('chapter')." ".$verseData['chap']."</h3><p class=\"backtotop\"><a onclick=\"scrollToTop()\">".$this->langLabelsModel->getLabel('backtotop')."</a></p>\r\n";
                $tocChaps['chap'.$verseData['chap']] = $verseData['chap'];
            }

            // Add verse to the resulting HTML.
            $text .= "<p><strong>".$verseData['vers']."</strong> ".$this->bibleJsonModel->getVerse($verseID)."</p>";
        }//end foreach

        // Prepare the form for selecting a book.
        // First, include all other existing GET parameters.
        $tocText = '<form name="selectabook" action="index.php" method="GET"><label for="SELECT_BOOK">'.$this->langLabelsModel->getLabel('selectbook').':</label>';
        foreach ($_GET as $getKey => $getValue) {
            if ($getKey === GetParams::PARAM_BOOK) {
                continue;
            }

            if (is_string($getKey) !== true) {
                throw new OomException('GET parameter key "'.var_export($getKey, true).'" is not string');
            }

            if ($this->getParams->isKnownParam($getKey) !== true) {
                throw new OomException('Unknown GET parameter "'.$getKey.'" with value: "'.var_export($getValue, true).'"');
            }

            if (is_string($getValue) !== true) {
                throw new OomException('GET parameter "'.$getKey.'" is not a string: "'.var_export($getValue, true).'"');
            }

            $tocText .= '<input type="hidden" name="'.$getKey.'" value="'.$getValue.'">';
        }

        // Render the combobox for selecting a book.
        $tocText .= '<select id="SELECT_BOOK" name="'.GetParams::PARAM_BOOK.'" onchange="document.forms[\'selectabook\'].submit();"><option value="">-</option>';
        foreach ($toc as $bookID => $bookData) {
            $tocBookName = $bookData;
            $addition    = '';
            if ($selectBook === $bookID) {
                $addition = ' selected="selected"';
            }

            $tocText .= '<option value="'.$bookID.'"'.$addition.'>'.$tocBookName.'</option>';
        }

        // End of form for selecting a book.
        $tocText .= '</select></form>';

        // Prepare the form for jumping to a chapter (not a real form, just JS scrolling to a particular heading).
        if (count($tocChaps) > 0) {
            $tocText .= "<form><label for=\"SELECT_CHAPTER\">".$this->langLabelsModel->getLabel('selectchapter').":</label><select id=\"SELECT_CHAPTER\" onchange=\"scrollToElement(this.value)\">";
            foreach ($tocChaps as $tocLink => $tocName) {
                $tocText .= "<option value=\"${tocLink}\">".$tocName."</option>";
            }

            $tocText .= "</select></form>";
        }

        // Include Bible translation heading and its metadata.
        $meta      = '';
        $bibleData = explode('|', $this->getParams->getParam(GetParams::PARAM_BIBLE));
        if (count($bibleData) === 2) {
            $metaData = $this->bibleIndexModel->getBibleMeta($bibleData[0], $bibleData[1]);
            $title    = '';
            if (array_key_exists('TITLE', $metaData) === true) {
                $title = $metaData['TITLE'];
            }

            $meta = "<h1>${title}</h1><details><summary>".$this->langLabelsModel->getLabel('details')."</summary><table>";
            foreach ($metaData as $metaKey => $metaValue) {
                $metaValueTrimmed = trim($metaValue);
                if ($metaKey === 'TITLE' || $metaValueTrimmed === '') {
                    continue;
                }

                $meta .= '<tr><th>'.$this->langLabelsModel->getLabel("meta${metaKey}").'</th><td>'.$metaValueTrimmed.'</td></tr>';
            }

            $meta .= '</table></details>';
        }//end if

        return "${meta}\r\n${tocText}\r\n${text}";

    }//end renderBible()


}//end class
