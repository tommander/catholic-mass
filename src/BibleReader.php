<?php
/**
 * BibleReader unit
 *
 * @package OrderOfMass
 * @author  Tommander <tommander@tommander.cz>
 * @license MIT license https://opensource.org/licenses/MIT
 */

declare(strict_types=1);

namespace TMD\OrderOfMass;

use TMD\OrderOfMass\Models\{BibleindexModel,BiblejsonModel,BiblemapModel,BooklistModel,LanglabelsModel};

if (defined('OOM_BASE') !== true) {
    die('This file cannot be viewed independently.');
}

/**
 * Reader for Zefania Bible translations.
 *
 * This class can get verses based on verse references, translate book numbers to book names and render whole Bible translation.
 *
 * It is working with the submodule `zefania-bibles`, where it reads the JSON files generated from original XMLs.
 */
class BibleReader
{

    /**
     * Whether to take verse parts into account.
     *
     * This is an EXPERIMENTAL functionality and doesn't always work correctly, that is why this constant is `false` by default.
     *
     * This is how the constant works e.g. for reference "Ps 9:10a":
     *
     * - Constant is `false`: verse reference will process this as "Ps 9:10"
     * - Constant is `true`: only first part of the 10th verse will be returned
     *
     * @var boolean
     */
    private $allowSubref = false;

    /**
     * GetParams service instance
     *
     * @var GetParams
     */
    private $getParams;

    /**
     * Logger service instance
     *
     * @var Logger
     */
    private $logger;

    /**
     * Language service instance
     *
     * @var Language
     */
    private $language;

    /**
     * Hello
     *
     * @var BibleindexModel
     */
    private $bibleIndexModel;

    /**
     * Hello
     *
     * @var BiblejsonModel
     */
    private $bibleJsonModel;

    /**
     * Hello
     *
     * @var BiblemapModel
     */
    private $bibleMapModel;

    /**
     * Hello
     *
     * @var BooklistModel
     */
    private $bookListModel;

    /**
     * Hello
     *
     * @var LanglabelsModel
     */
    private $langLabelsModel;


    /**
     * Generate a unique verse reference number
     *
     * The range of an (un)signed 32b integer should be sufficient for the returned number.
     *
     * @param int $book Book number
     * @param int $chap Chapter number (3 digits)
     * @param int $ver  Verse number (3 digits)
     * @param int $part Part number (1 digit)
     *
     * @return int
     */
    private static function refVer(int $book, int $chap, int $ver, int $part=0): int
    {
        return (int) sprintf('%d%03d%03d%01d', $book, $chap, $ver, $part);

    }//end refVer()


    /**
     * Decodes a unique verse reference number generated by {@see BibleReader::refVer()}.
     *
     * @param int $refVer Unique verse reference number.
     *
     * @return array
     */
    private static function decodeRefVer(int $refVer): array
    {
        $ret = [
            'book' => 0,
            'chap' => 0,
            'vers' => 0,
            'part' => 0,
        ];

        $strRefVer = strval($refVer);
        if (preg_match('/^(\d+)(\d{3})(\d{3})(\d{1})$/', $strRefVer, $mat) === 1) {
            $ret['book'] = $mat[1];
            $ret['chap'] = $mat[2];
            $ret['vers'] = $mat[3];
            $ret['part'] = $mat[4];
        }

        return $ret;

    }//end decodeRefVer()


    /**
     * Constructor
     *
     * Saves service instances and loads Bible translations list
     *
     * @param Logger          $logger          Logger service
     * @param GetParams       $getParams       GetParams service
     * @param Language        $language        Language service
     * @param BibleindexModel $bibleIndexModel Bibleindex model
     * @param BiblejsonModel  $bibleJsonModel  Biblejson model
     * @param BiblemapModel   $bibleMapModel   Biblemap model
     * @param BooklistModel   $bookListModel   Booklist model
     * @param LanglabelsModel $langLabelsModel Langlabels model
     */
    public function __construct(Logger $logger, GetParams $getParams, Language $language, BibleindexModel $bibleIndexModel, BiblejsonModel $bibleJsonModel, BiblemapModel $bibleMapModel, BooklistModel $bookListModel, LanglabelsModel $langLabelsModel)
    {
        // Services.
        $this->logger          = $logger;
        $this->getParams       = $getParams;
        $this->language        = $language;
        $this->bibleIndexModel = $bibleIndexModel;
        $this->bibleJsonModel  = $bibleJsonModel;
        $this->bibleMapModel   = $bibleMapModel;
        $this->bookListModel   = $bookListModel;
        $this->langLabelsModel = $langLabelsModel;

    }//end __construct()


    /**
     * Sort of "pre-function" for {@see BiblejsonModel::getVerseRange()} which parses the given verse reference and book abbreviation.
     *
     * @param string $ref Verse reference
     *
     * @return string
     */
    public function getVerse(string $ref): string
    {
        $ret       = '';
        $parsedRef = $this->parseRef($ref);

        foreach ($parsedRef as $oneRef) {
            if ($ret !== '') {
                $ret .= ' ';
            }

            $ret .= $this->bibleJsonModel->getVerseRange($oneRef[0], $oneRef[1]);
        }

        return $ret;

    }//end getVerse()


    /**
     * Parse single string reference to elementary parts.
     *
     * This is important for the XML parser to be able to follow any possible verse reference.
     *
     * It is important to note that the input reference may only contain one book ref.
     *
     * Parsing `Ps 1:2-3, 4b-2:4+5` would give this result:
     *
     * ```
     * array(
     *     ['Ps', 1000200, 1000300],
     *     ['Ps', 1000202, 2000400],
     *     ['Ps', 2000500, 2000500]
     * )
     * ```
     *
     * @param string $ref One reference
     *
     * @return array
     */
    public function parseRef(string $ref): array
    {
        // Check that book reference and the rest of the reference was found.
        if (preg_match('/^([\p{L}0-9]+)\s+(.*)$/u', $ref, $mat) !== 1 || count($mat) < 3) {
            return [];
        }

        // Save basic reference parts for clarity.
        $book    = $mat[1];
        $chap    = 0;
        $bookNum = $this->bookListModel->abbreviationToNumber($book);
        if ($bookNum === null) {
            return [];
        }

        // Split reference into single verses or verse ranges.
        $rngArr = [];
        $rngTok = strtok($mat[2], ',+');
        while ($rngTok !== false) {
            $rngArr[] = $rngTok;
            $rngTok   = strtok(',+');
        }

        // Unification of all single verse/verse range refs, so that
        // they all have book and chapter.
        $rng = [];
        foreach ($rngArr as $rngOne) {
            if (preg_match('/(([0-9]+):)?([0-9A-z]+)(-)?(([0-9]+):)?([0-9A-z]+)?/', $rngOne, $mat2) === 1) {
                $verseLow  = '';
                $verseHigh = '';

                if (count($mat2) === 4) {
                    if ($mat2[2] !== '') {
                        $chap = intval($mat2[2]);
                    }

                    if (preg_match('/(\d+)([A-z]{1})/', $mat2[3], $mat3) === 1) {
                        if ($this->allowSubref === true) {
                            $verseLow = self::refVer($bookNum, $chap, intval($mat3[1]), Helper::letterToInt($mat3[2]));
                        } else {
                            $verseLow = self::refVer($bookNum, $chap, intval($mat3[1]));
                        }
                    } else {
                        $verseLow = self::refVer($bookNum, $chap, intval($mat2[3]));
                    }

                    $verseHigh = $verseLow;
                } else if (count($mat2) === 8) {
                    if ($mat2[2] !== '') {
                        $chap = intval($mat2[2]);
                    }

                    if (preg_match('/(\d+)([A-z]{1})/', $mat2[3], $mat4) === 1) {
                        if ($this->allowSubref === true) {
                            $verseLow = self::refVer($bookNum, $chap, intval($mat4[1]), Helper::letterToInt($mat4[2]));
                        } else {
                            $verseLow = self::refVer($bookNum, $chap, intval($mat4[1]));
                        }
                    } else {
                        $verseLow = self::refVer($bookNum, $chap, intval($mat2[3]));
                    }

                    if ($mat2[6] !== '') {
                        $chap = intval($mat2[6]);
                    }

                    if (preg_match('/(\d+)([A-z]{1})/', $mat2[7], $mat5) === 1) {
                        if ($this->allowSubref === true) {
                            $verseHigh = self::refVer($bookNum, $chap, intval($mat5[1]), Helper::letterToInt($mat5[2]));
                        } else {
                            $verseHigh = self::refVer($bookNum, $chap, intval($mat5[1]));
                        }
                    } else {
                        $verseHigh = self::refVer($bookNum, $chap, intval($mat2[7]));
                    }
                }//end if

                $rng[] = [
                    $verseLow,
                    $verseHigh,
                ];
            }//end if
        }//end foreach

        return $rng;

    }//end parseRef()


    /**
     * Allows for parsing either a single string reference or an array of string references.
     *
     * Basically it is just a <q>gate</q> to {@see BibleReader::parseRef()}.
     *
     * @param string|string[] $refs Reference(s)
     *
     * @return array
     */
    public function parseRefs($refs): array
    {
        if (is_string($refs) === true) {
            return $this->parseRef($refs);
        }

        $arr = [];
        foreach ($refs as $oneref) {
            $arr = array_merge($arr, $this->parseRef($oneref));
        }

        return $arr;

    }//end parseRefs()


    /**
     * Renders the whole current Bible translation.
     *
     * @return string
     */
    public function renderBible(): string
    {
        $toc        = [];
        $text       = '';
        $tocChaps   = [];
        $selectBook = $this->getParams->getParam(GetParams::PARAM_BOOK);

        $verses = $this->bibleJsonModel->listVerses();
        if ($verses === null) {
            return '';
        }

        foreach ($verses as $verseID) {
            $verseData = self::decodeRefVer($verseID);
            $bookNum   = intval($verseData['book']);

            if (array_key_exists(strval($bookNum), $toc) !== true) {
                $bookName = '';

                $bookNameTmp = $this->bibleMapModel->numberToName($bookNum);
                if ($bookNameTmp !== null) {
                    $bookName = $bookNameTmp;
                } else {
                    $bookNameTmp = $this->bookListModel->numberToName($bookNum);
                    if ($bookNameTmp !== null) {
                        $bookName = $bookNameTmp;
                    }
                }

                $toc[strval($bookNum)] = $bookName;
            }

            if ($selectBook !== $verseData['book']) {
                continue;
            }

            $chapNum = intval($verseData['chap']);
            $versNum = intval($verseData['vers']);

            if (intval($verseData['chap']) === 1 && intval($verseData['vers']) === 1) {
                $text .= "<h2>".$toc[strval($bookNum)]."</h2>\r\n";
            }

            if (intval($verseData['vers']) === 1) {
                $text .= "<h3 id=\"chap${chapNum}\">".$this->langLabelsModel->getLabel('chapter')." ".$chapNum."</h3><p class=\"backtotop\"><a onclick=\"scrollToTop()\">".$this->langLabelsModel->getLabel('backtotop')."</a></p>\r\n";
                $tocChaps["chap${chapNum}"] = $chapNum;
            }

            $text .= "<p><strong>".$versNum."</strong> ".$this->bibleJsonModel->getVerse(intval($verseID))."</p>";
        }//end foreach

        $tocText = '<form name="selectabook" action="index.php" method="GET"><label for="SELECT_BOOK">'.$this->langLabelsModel->getLabel('selectbook').':</label>';
        foreach ($_GET as $getKey => $getValue) {
            if ($getKey === 'book') {
                continue;
            }

            if (is_string($getValue) !== true) {
                continue;
            }

            $tocText .= '<input type="hidden" name="'.$getKey.'" value="'.$getValue.'">';
        }

        $tocText .= '<select id="SELECT_BOOK" name="book" onchange="document.forms[\'selectabook\'].submit();"><option value="">-</option>';
        foreach ($toc as $bookID => $bookData) {
            $tocBookName = $bookData;
            $addition    = '';
            if ($selectBook === strval($bookID)) {
                $addition = ' selected="selected"';
            }

            $tocText .= '<option value="'.$bookID.'"'.$addition.'>'.$tocBookName.'</option>';
        }

        $tocText .= '</select></form>';

        if (count($tocChaps) > 0) {
            $tocText .= "<form><label for=\"SELECT_CHAPTER\">".$this->langLabelsModel->getLabel('selectchapter').":</label><select id=\"SELECT_CHAPTER\" onchange=\"scrollToElement(this.value)\">";
            foreach ($tocChaps as $tocLink => $tocName) {
                $tocText .= "<option value=\"${tocLink}\">${tocName}</option>";
            }

            $tocText .= "</select></form>";
        }

        $meta      = '';
        $bibleData = explode('|', $this->getParams->getParam(GetParams::PARAM_BIBLE));
        if (count($bibleData) === 2) {
            $metaData = $this->bibleIndexModel->getBibleMeta($bibleData[0], $bibleData[1]);
            if ($metaData !== null) {
                $title = '';
                if (array_key_exists('TITLE', $metaData) === true) {
                    $title = $metaData['TITLE'];
                }

                $meta = "<h1>${title}</h1><details><summary>".$this->langLabelsModel->getLabel('details')."</summary><table>";
                foreach ($metaData as $metaKey => $metaValue) {
                    $metaValueTrimmed = trim($metaValue);
                    if ($metaKey === 'TITLE' || $metaValueTrimmed === '') {
                        continue;
                    }

                    $meta .= '<tr><th>'.$this->langLabelsModel->getLabel("meta${metaKey}").'</th><td>'.htmlspecialchars($metaValueTrimmed).'</td></tr>';
                }

                $meta .= '</table></details>';
            }
        }//end if

        return "$meta\r\n${tocText}\r\n${text}";

    }//end renderBible()


}//end class
