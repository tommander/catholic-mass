<?php
/**
 * BibleReader unit
 *
 * @package OrderOfMass
 * @author  Tommander <tommander@tommander.cz>
 * @license MIT license https://opensource.org/licenses/MIT
 */

namespace TMD\OrderOfMass;

if (defined('OOM_BASE') !== true) {
    die('This file cannot be viewed independently.');
}

/**
 * Reader for Zefania Bible translations.
 */
class BibleReader
{

    /**
     * JSON index file of the Bible translation.
     *
     * This file contains a single object with one property per verse (each property's key is a unique verse reference number).
     *
     * @var array
     */
    private $jsonFile = [];

    /**
     * Map file of the Bible translation.
     *
     * This file contains mapping of unique book numbers to their abbreviations specific for that translation.
     *
     * If the translation does not contain any abbreviations, this file might also just be an empty JSON array.
     *
     * @var array<string, array>
     */
    private $mapFile = [];

    /**
     * Meta file of the Bible translation.
     *
     * This file contains all information included in the original translation.
     *
     * @var array
     */
    private $metaFile = [];

    /**
     * Index of available Bible translations
     *
     * @var array
     */
    private $indexJson = [];

    /**
     * Current translation per GET parameter
     *
     * @var string
     */
    private $currentTranslation = '';

    /**
     * Index of book translations
     *
     * Key is abbreviation, value is full English name
     *
     * @var array
     */
    private $bookIndex = [];

    /**
     * Index of book translations
     *
     * Simple array of abbreviations to get using integer key
     *
     * @var array
     */
    private $bookIndexNumAbbr = [];

    /**
     * Index of book translations
     *
     * Simple array of full names to get  using integer key
     *
     * @var array
     */
    private $bookIndexNumFull = [];

    /**
     * GetParams service instance
     *
     * @var GetParams
     */
    private $svcGetParams;

    /**
     * Logger service instance
     *
     * @var Logger
     */
    private $svcLogger;

    /**
     * Language service instance
     *
     * @var Language
     */
    private $svcLanguage;


    /**
     * Generate a unique verse reference number
     *
     * The range of an (un)signed 32b integer should be sufficient for the returned number.
     *
     * @param int $book Book number
     * @param int $chap Chapter number (3 digits)
     * @param int $ver  Verse number (3 digits)
     * @param int $part Part number (1 digit)
     *
     * @return int
     */
    private static function refVer(int $book, int $chap, int $ver, int $part=0): int
    {
        return (int) sprintf('%d%03d%03d%01d', $book, $chap, $ver, $part);

    }//end refVer()


    /**
     * Decodes a unique verse reference number generated by {@see BibleReader::refVer()}.
     *
     * @param int $refVer Unique verse reference number.
     *
     * @return array
     */
    private static function decodeRefVer(int $refVer): array
    {
        $ret = [
            'book' => 0,
            'chap' => 0,
            'vers' => 0,
            'part' => 0,
        ];

        $strRefVer = strval($refVer);
        if (preg_match('/^(\d+)(\d{3})(\d{3})(\d{1})$/', $strRefVer, $mat) === 1) {
            $ret['book'] = $mat[1];
            $ret['chap'] = $mat[2];
            $ret['vers'] = $mat[3];
            $ret['part'] = $mat[4];
        }

        return $ret;

    }//end decodeRefVer()


    /**
     * Constructor
     *
     * @param Logger    $logger    Logger service instance
     * @param GetParams $getParams GetParams service instance
     * @param Language  $language  Language service instance
     */
    public function __construct(Logger $logger, GetParams $getParams, Language $language)
    {
        $this->svcLogger          = $logger;
        $this->svcGetParams       = $getParams;
        $this->svcLanguage        = $language;
        $this->currentTranslation = $this->svcGetParams->getBible();

        $this->indexJson = Helper::loadJson('libs/zefania-bibles/index.min.json', true);
        $this->bookIndex = Helper::loadJson('assets/json/booklist.json', true);

        $this->bookIndexNumAbbr = array_keys($this->bookIndex);
        $this->bookIndexNumFull = array_values($this->bookIndex);

        $currentTranslationData = explode('|', $this->currentTranslation);
        if (count($currentTranslationData) === 2
            && isset($this->indexJson[$currentTranslationData[0]][$currentTranslationData[1]]['file']) === true
        ) {
            $fileName = $this->indexJson[$currentTranslationData[0]][$currentTranslationData[1]]['file'];

            $this->jsonFile = Helper::loadJson('libs/zefania-bibles/json/'.$fileName);
            $this->mapFile  = Helper::loadJson('libs/zefania-bibles/map/'.$fileName);
            $this->metaFile = Helper::loadJson('libs/zefania-bibles/meta/'.$fileName);
        }

    }//end __construct()


    /**
     * Short description
     *
     * @return array
     */
    public function getBibleList(): array
    {
        $ret = [
            '' => [
                [
                    'value' => '',
                    'sel'   => false,
                    'text'  => '-',
                ],
            ],
        ];

        $langLabels  = $this->svcGetParams->getLabelLang();
        $langContent = $this->svcGetParams->getContentLang();

        foreach ($this->indexJson as $lang => $langCont) {
            if (is_string($lang) !== true) {
                continue;
            }

            if ($lang !== $langLabels && $lang !== $langContent) {
                continue;
            }

            foreach ($langCont as $bibleId => $bibleData) {
                $val  = $lang.'|'.$bibleId;
                $sel  = ($this->currentTranslation === $val);
                $text = 'NO TITLE';
                if (isset($bibleData['meta']['TITLE']) === true) {
                    $text = $bibleData['meta']['TITLE'];
                }

                if (isset($ret[$lang]) !== true) {
                    $ret[$lang] = [];
                }

                $ret[$lang][] = [
                    'value' => urlencode($val),
                    'sel'   => $sel,
                    'text'  => $text,
                ];
            }
        }//end foreach

        return $ret;

    }//end getBibleList()


    /**
     * Returns the Bible book abbreviation as used in the currently loaded translation.
     *
     * If no such abbreviation is defined in the translation, a common abbreviation is returned.
     *
     * @param string $commonAbbr Either a common Bible book abbreviation or a unique Bible book number.
     *
     * @return array|false
     *
     * @todo Rename or separate abbr and full to make it clear
     */
    public function localizedAbbr(string $commonAbbr): array|false
    {
        $bookNum = $this->bookAbbrToNum($commonAbbr);
        if ($bookNum === false) {
            return false;
        }

        if (array_key_exists(strval($bookNum), $this->mapFile) !== true) {
            return false;
        }

        return $this->mapFile[strval($bookNum)];

    }//end localizedAbbr()


    /**
     * Translate a common book abbreviation to full English name
     *
     * @param string $commonAbbr Common Bible book abbrevation
     *
     * @return string|false
     */
    public function bookAbbrToFull(string $commonAbbr): string|false
    {
        if (isset($this->bookIndex[$commonAbbr]) !== true) {
            return false;
        }

        return $this->bookIndex[$commonAbbr];

    }//end bookAbbrToFull()


    /**
     * Translate book number to common book abbreviation
     *
     * @param int $bookNum Book number (1..99)
     *
     * @return string|false
     */
    public function bookNumToAbbr(int $bookNum): string|false
    {
        if (array_key_exists(($bookNum - 1), $this->bookIndexNumAbbr) !== true) {
            return false;
        }

        return $this->bookIndexNumAbbr[($bookNum - 1)];

    }//end bookNumToAbbr()


    /**
     * Translate book number to full English book name
     *
     * @param int $bookNum Book number (1..99)
     *
     * @return string|false
     */
    public function bookNumToFull(int $bookNum): string|false
    {
        if (array_key_exists(($bookNum - 1), $this->bookIndexNumFull) !== true) {
            return false;
        }

        return $this->bookIndexNumFull[($bookNum - 1)];

    }//end bookNumToFull()


    /**
     * Translate common book abbreviation to book number
     *
     * @param string $bookAbbr Common Bible book abbreviation
     *
     * @return int|false
     */
    public function bookAbbrToNum(string $bookAbbr): int|false
    {
        $ret = array_search($bookAbbr, $this->bookIndexNumAbbr);
        if ($ret === false || is_int($ret) !== true) {
            return false;
        }

        return ($ret + 1);

    }//end bookAbbrToNum()


    /**
     * Returns the verses beginning with `$refVerStart` and ending with `$refVerEnd`.
     *
     * @param int $refVerStart First verse (unique verse reference number)
     * @param int $refVerEnd   Last verse (unique verse reference number)
     *
     * @return string
     */
    public function readVerse(int $refVerStart, int $refVerEnd): string
    {
        $ret = '';
        foreach ($this->jsonFile as $verseRef => $verseText) {
            $verseRefNum = intval($verseRef);
            if ($verseRefNum < $refVerStart || $verseRefNum > $refVerEnd) {
                continue;
            }

            if ($ret !== '') {
                $ret .= ' ';
            }

            $ret .= $verseText;
        }

        return $ret;

    }//end readVerse()


    /**
     * Sort of "pre-function" for {@see BibleReader::readVerse()} which parses the given verse reference and book abbreviation.
     *
     * @param string $ref Verse reference
     *
     * @return string
     */
    public function getVerse(string $ref): string
    {
        $ret       = '';
        $parsedRef = $this->parseRef($ref);

        foreach ($parsedRef as $oneRef) {
            if ($ret !== '') {
                $ret .= ' ';
            }

            $ret .= $this->readVerse($oneRef[0], $oneRef[1]);
        }

        return $ret;

    }//end getVerse()


    /**
     * Parse single string reference to elementary parts.
     *
     * This is important for the XML parser to be able to follow any possible verse reference.
     *
     * It is important to note that the input reference may only contain one book ref.
     *
     * Parsing `Ps 1:2-3, 4b-2:4+5` would give this result:
     *
     * ```
     * array(
     *     ['Ps', 1000200, 1000300],
     *     ['Ps', 1000202, 2000400],
     *     ['Ps', 2000500, 2000500]
     * )
     * ```
     *
     * @param string $ref One reference
     *
     * @return array
     */
    public function parseRef(string $ref): array
    {
        // Check that book reference and the rest of the reference was found.
        if (preg_match('/^([\p{L}0-9]+)\s+(.*)$/u', $ref, $mat) !== 1 || count($mat) < 3) {
            return [];
        }

        // Save basic reference parts for clarity.
        $book    = $mat[1];
        $chap    = 0;
        $bookNum = $this->bookAbbrToNum($book);
        if ($bookNum === false) {
            return [];
        }

        // Split reference into single verses or verse ranges.
        $rngArr = [];
        $rngTok = strtok($mat[2], ',+');
        while ($rngTok !== false) {
            $rngArr[] = $rngTok;
            $rngTok   = strtok(',+');
        }

        // Unification of all single verse/verse range refs, so that
        // they all have book and chapter.
        $rng = [];
        foreach ($rngArr as $rngOne) {
            if (preg_match('/(([0-9]+):)?([0-9A-z]+)(-)?(([0-9]+):)?([0-9A-z]+)?/', $rngOne, $mat2) === 1) {
                $verseLow  = '';
                $verseHigh = '';

                if (count($mat2) === 4) {
                    if ($mat2[2] !== '') {
                        $chap = intval($mat2[2]);
                    }

                    if (preg_match('/(\d+)([A-z]{1})/', $mat2[3], $mat3) === 1) {
                        $verseLow = self::refVer($bookNum, $chap, intval($mat3[1]), Helper::letterToInt($mat3[2]));
                    } else {
                        $verseLow = self::refVer($bookNum, $chap, intval($mat2[3]));
                    }

                    $verseHigh = $verseLow;
                } else if (count($mat2) === 8) {
                    if ($mat2[2] !== '') {
                        $chap = intval($mat2[2]);
                    }

                    if (preg_match('/(\d+)([A-z]{1})/', $mat2[3], $mat4) === 1) {
                        $verseLow = self::refVer($bookNum, $chap, intval($mat4[1]), Helper::letterToInt($mat4[2]));
                    } else {
                        $verseLow = self::refVer($bookNum, $chap, intval($mat2[3]));
                    }

                    if ($mat2[6] !== '') {
                        $chap = intval($mat2[6]);
                    }

                    if (preg_match('/(\d+)([A-z]{1})/', $mat2[7], $mat5) === 1) {
                        $verseHigh = self::refVer($bookNum, $chap, intval($mat5[1]), Helper::letterToInt($mat5[2]));
                    } else {
                        $verseHigh = self::refVer($bookNum, $chap, intval($mat2[7]));
                    }
                }//end if

                $rng[] = [
                    $verseLow,
                    $verseHigh,
                ];
            }//end if
        }//end foreach

        return $rng;

    }//end parseRef()


    /**
     * Allows for parsing either a single string reference or an array of string references.
     *
     * Basically it is just a <q>gate</q> to {@see BibleReader::parseRef()}.
     *
     * @param string|string[] $refs Reference(s)
     *
     * @return array
     */
    public function parseRefs($refs): array
    {
        if (is_string($refs) === true) {
            return $this->parseRef($refs);
        }

        $arr = [];
        foreach ($refs as $oneref) {
            $arr = array_merge($arr, $this->parseRef($oneref));
        }

        return $arr;

    }//end parseRefs()


    /**
     * Renders the whole current Bible translation.
     *
     * @return string
     */
    public function renderBible(): string
    {
        $toc        = [];
        $verses     = '';
        $tocChaps   = [];
        $selectBook = $this->svcGetParams->getSelectBook();

        foreach ($this->jsonFile as $verseID => $verseText) {
            $verseData = self::decodeRefVer($verseID);
            $bookNum   = intval($verseData['book']);

            if (array_key_exists(strval($bookNum), $toc) !== true) {
                $bookName = '';
                if (array_key_exists($bookNum, $this->mapFile) === true) {
                    $bookName = $this->mapFile[$bookNum]['full'];
                }

                if ($bookName === '') {
                    $bookName = $this->bookNumToFull($bookNum);
                }

                $toc[strval($bookNum)] = $bookName;
            }

            if ($selectBook !== $verseData['book']) {
                continue;
            }

            $chapNum = intval($verseData['chap']);
            $versNum = intval($verseData['vers']);

            if (intval($verseData['chap']) === 1 && intval($verseData['vers']) === 1) {
                $verses .= "<h2>".$toc[strval($bookNum)]."</h2>\r\n";
            }

            if (intval($verseData['vers']) === 1) {
                $verses .= "<h3 id=\"chap${chapNum}\">".$this->svcLanguage->repls('@{chapter}')." ".$chapNum."</h3><p class=\"backtotop\"><a onclick=\"scrollToTop()\">".$this->svcLanguage->repls('@{backtotop}')."</a></p>\r\n";
                $tocChaps["chap${chapNum}"] = $chapNum;
            }

            $verses .= "<p><strong>".$versNum."</strong> ".$verseText."</p>";
        }//end foreach

        $tocText = '<form name="selectabook" action="index.php" method="GET"><label for="SELECT_BOOK">'.$this->svcLanguage->repls('@{selectbook}').':</label>';
        foreach ($_GET as $getKey => $getValue) {
            if ($getKey === 'book') {
                continue;
            }

            if (is_string($getValue) !== true) {
                continue;
            }

            $tocText .= '<input type="hidden" name="'.$getKey.'" value="'.$getValue.'">';
        }

        $tocText .= '<select id="SELECT_BOOK" name="book" onchange="document.forms[\'selectabook\'].submit();"><option value="">-</option>';
        foreach ($toc as $bookID => $bookData) {
            $tocBookName = $bookData;
            $addition    = '';
            if ($selectBook === strval($bookID)) {
                $addition = ' selected="selected"';
            }

            $tocText .= '<option value="'.$bookID.'"'.$addition.'>'.$tocBookName.'</option>';
        }

        $tocText .= '</select></form>';

        if (count($tocChaps) > 0) {
            $tocText .= "<form><label for=\"SELECT_CHAPTER\">".$this->svcLanguage->repls('@{selectchapter}').":</label><select id=\"SELECT_CHAPTER\" onchange=\"scrollToElement(this.value)\">";
            foreach ($tocChaps as $tocLink => $tocName) {
                $tocText .= "<option value=\"${tocLink}\">${tocName}</option>";
            }

            $tocText .= "</select></form>";
        }

        $meta = '';
        if (isset($this->metaFile['meta']) === true
            && is_array($this->metaFile['meta']) === true
            && isset($this->metaFile['meta']['TITLE']) === true
        ) {
            $meta = "<h1>".$this->metaFile['meta']['TITLE']."</h1><details><summary>Details</summary><table>";
            foreach ($this->metaFile['meta'] as $metaKey => $metaValue) {
                $metaValueTrimmed = trim($metaValue);
                if ($metaKey === 'TITLE' || $metaValueTrimmed === '') {
                    continue;
                }

                $meta .= '<tr><th>'.strtolower($metaKey).'</th><td>'.htmlspecialchars($metaValueTrimmed).'</td></tr>';
            }

            $meta .= '</table></details>';
        }

        return "$meta\r\n${tocText}\r\n${verses}";

    }//end renderBible()


}//end class
